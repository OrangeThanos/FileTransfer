// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/Transfer.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_protos_2fTransfer_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_protos_2fTransfer_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/empty.pb.h>
#include "protos/Files.pb.h"
#include "protos/User.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_protos_2fTransfer_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_protos_2fTransfer_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_protos_2fTransfer_2eproto;
class FileRecieveRequest;
struct FileRecieveRequestDefaultTypeInternal;
extern FileRecieveRequestDefaultTypeInternal _FileRecieveRequest_default_instance_;
class FileTransferError;
struct FileTransferErrorDefaultTypeInternal;
extern FileTransferErrorDefaultTypeInternal _FileTransferError_default_instance_;
class FileTransferPart;
struct FileTransferPartDefaultTypeInternal;
extern FileTransferPartDefaultTypeInternal _FileTransferPart_default_instance_;
class FileTransferProgress;
struct FileTransferProgressDefaultTypeInternal;
extern FileTransferProgressDefaultTypeInternal _FileTransferProgress_default_instance_;
class FileTransferRequest;
struct FileTransferRequestDefaultTypeInternal;
extern FileTransferRequestDefaultTypeInternal _FileTransferRequest_default_instance_;
class FileTransferRequestInit;
struct FileTransferRequestInitDefaultTypeInternal;
extern FileTransferRequestInitDefaultTypeInternal _FileTransferRequestInit_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::FileRecieveRequest* Arena::CreateMaybeMessage<::FileRecieveRequest>(Arena*);
template<> ::FileTransferError* Arena::CreateMaybeMessage<::FileTransferError>(Arena*);
template<> ::FileTransferPart* Arena::CreateMaybeMessage<::FileTransferPart>(Arena*);
template<> ::FileTransferProgress* Arena::CreateMaybeMessage<::FileTransferProgress>(Arena*);
template<> ::FileTransferRequest* Arena::CreateMaybeMessage<::FileTransferRequest>(Arena*);
template<> ::FileTransferRequestInit* Arena::CreateMaybeMessage<::FileTransferRequestInit>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum TransferError : int {
  SRC_DISCONNECT = 0,
  SRC_FILEMISSING = 1,
  SRC_ACCESSDENIED = 2,
  DST_DISCONNECT = 100,
  DST_UNEXPERROR = 101,
  DST_ACCESSDENIED = 102,
  TransferError_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TransferError_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TransferError_IsValid(int value);
constexpr TransferError TransferError_MIN = SRC_DISCONNECT;
constexpr TransferError TransferError_MAX = DST_ACCESSDENIED;
constexpr int TransferError_ARRAYSIZE = TransferError_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TransferError_descriptor();
template<typename T>
inline const std::string& TransferError_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TransferError>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TransferError_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TransferError_descriptor(), enum_t_value);
}
inline bool TransferError_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TransferError* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TransferError>(
    TransferError_descriptor(), name, value);
}
// ===================================================================

class FileTransferRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:FileTransferRequest) */ {
 public:
  inline FileTransferRequest() : FileTransferRequest(nullptr) {}
  ~FileTransferRequest() override;
  explicit PROTOBUF_CONSTEXPR FileTransferRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileTransferRequest(const FileTransferRequest& from);
  FileTransferRequest(FileTransferRequest&& from) noexcept
    : FileTransferRequest() {
    *this = ::std::move(from);
  }

  inline FileTransferRequest& operator=(const FileTransferRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileTransferRequest& operator=(FileTransferRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileTransferRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileTransferRequest* internal_default_instance() {
    return reinterpret_cast<const FileTransferRequest*>(
               &_FileTransferRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(FileTransferRequest& a, FileTransferRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FileTransferRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileTransferRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FileTransferRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FileTransferRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FileTransferRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FileTransferRequest& from) {
    FileTransferRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileTransferRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "FileTransferRequest";
  }
  protected:
  explicit FileTransferRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSrcFileFieldNumber = 1,
  };
  // string SrcFile = 1;
  void clear_srcfile();
  const std::string& srcfile() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_srcfile(ArgT0&& arg0, ArgT... args);
  std::string* mutable_srcfile();
  PROTOBUF_NODISCARD std::string* release_srcfile();
  void set_allocated_srcfile(std::string* srcfile);
  private:
  const std::string& _internal_srcfile() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_srcfile(const std::string& value);
  std::string* _internal_mutable_srcfile();
  public:

  // @@protoc_insertion_point(class_scope:FileTransferRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr srcfile_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fTransfer_2eproto;
};
// -------------------------------------------------------------------

class FileRecieveRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:FileRecieveRequest) */ {
 public:
  inline FileRecieveRequest() : FileRecieveRequest(nullptr) {}
  ~FileRecieveRequest() override;
  explicit PROTOBUF_CONSTEXPR FileRecieveRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileRecieveRequest(const FileRecieveRequest& from);
  FileRecieveRequest(FileRecieveRequest&& from) noexcept
    : FileRecieveRequest() {
    *this = ::std::move(from);
  }

  inline FileRecieveRequest& operator=(const FileRecieveRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileRecieveRequest& operator=(FileRecieveRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileRecieveRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileRecieveRequest* internal_default_instance() {
    return reinterpret_cast<const FileRecieveRequest*>(
               &_FileRecieveRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(FileRecieveRequest& a, FileRecieveRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FileRecieveRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileRecieveRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FileRecieveRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FileRecieveRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FileRecieveRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FileRecieveRequest& from) {
    FileRecieveRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileRecieveRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "FileRecieveRequest";
  }
  protected:
  explicit FileRecieveRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDstPathFieldNumber = 1,
    kFileInfoFieldNumber = 2,
  };
  // string DstPath = 1;
  void clear_dstpath();
  const std::string& dstpath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dstpath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dstpath();
  PROTOBUF_NODISCARD std::string* release_dstpath();
  void set_allocated_dstpath(std::string* dstpath);
  private:
  const std::string& _internal_dstpath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dstpath(const std::string& value);
  std::string* _internal_mutable_dstpath();
  public:

  // .File fileInfo = 2;
  bool has_fileinfo() const;
  private:
  bool _internal_has_fileinfo() const;
  public:
  void clear_fileinfo();
  const ::File& fileinfo() const;
  PROTOBUF_NODISCARD ::File* release_fileinfo();
  ::File* mutable_fileinfo();
  void set_allocated_fileinfo(::File* fileinfo);
  private:
  const ::File& _internal_fileinfo() const;
  ::File* _internal_mutable_fileinfo();
  public:
  void unsafe_arena_set_allocated_fileinfo(
      ::File* fileinfo);
  ::File* unsafe_arena_release_fileinfo();

  // @@protoc_insertion_point(class_scope:FileRecieveRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dstpath_;
    ::File* fileinfo_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fTransfer_2eproto;
};
// -------------------------------------------------------------------

class FileTransferPart final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:FileTransferPart) */ {
 public:
  inline FileTransferPart() : FileTransferPart(nullptr) {}
  ~FileTransferPart() override;
  explicit PROTOBUF_CONSTEXPR FileTransferPart(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileTransferPart(const FileTransferPart& from);
  FileTransferPart(FileTransferPart&& from) noexcept
    : FileTransferPart() {
    *this = ::std::move(from);
  }

  inline FileTransferPart& operator=(const FileTransferPart& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileTransferPart& operator=(FileTransferPart&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileTransferPart& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileTransferPart* internal_default_instance() {
    return reinterpret_cast<const FileTransferPart*>(
               &_FileTransferPart_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(FileTransferPart& a, FileTransferPart& b) {
    a.Swap(&b);
  }
  inline void Swap(FileTransferPart* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileTransferPart* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FileTransferPart* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FileTransferPart>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FileTransferPart& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FileTransferPart& from) {
    FileTransferPart::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileTransferPart* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "FileTransferPart";
  }
  protected:
  explicit FileTransferPart(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartFieldNumber = 1,
  };
  // bytes Part = 1;
  void clear_part();
  const std::string& part() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_part(ArgT0&& arg0, ArgT... args);
  std::string* mutable_part();
  PROTOBUF_NODISCARD std::string* release_part();
  void set_allocated_part(std::string* part);
  private:
  const std::string& _internal_part() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_part(const std::string& value);
  std::string* _internal_mutable_part();
  public:

  // @@protoc_insertion_point(class_scope:FileTransferPart)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr part_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fTransfer_2eproto;
};
// -------------------------------------------------------------------

class FileTransferProgress final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:FileTransferProgress) */ {
 public:
  inline FileTransferProgress() : FileTransferProgress(nullptr) {}
  ~FileTransferProgress() override;
  explicit PROTOBUF_CONSTEXPR FileTransferProgress(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileTransferProgress(const FileTransferProgress& from);
  FileTransferProgress(FileTransferProgress&& from) noexcept
    : FileTransferProgress() {
    *this = ::std::move(from);
  }

  inline FileTransferProgress& operator=(const FileTransferProgress& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileTransferProgress& operator=(FileTransferProgress&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileTransferProgress& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileTransferProgress* internal_default_instance() {
    return reinterpret_cast<const FileTransferProgress*>(
               &_FileTransferProgress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(FileTransferProgress& a, FileTransferProgress& b) {
    a.Swap(&b);
  }
  inline void Swap(FileTransferProgress* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileTransferProgress* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FileTransferProgress* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FileTransferProgress>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FileTransferProgress& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FileTransferProgress& from) {
    FileTransferProgress::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileTransferProgress* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "FileTransferProgress";
  }
  protected:
  explicit FileTransferProgress(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileInfoFieldNumber = 2,
    kCurrentProgressFieldNumber = 1,
  };
  // .File fileInfo = 2;
  bool has_fileinfo() const;
  private:
  bool _internal_has_fileinfo() const;
  public:
  void clear_fileinfo();
  const ::File& fileinfo() const;
  PROTOBUF_NODISCARD ::File* release_fileinfo();
  ::File* mutable_fileinfo();
  void set_allocated_fileinfo(::File* fileinfo);
  private:
  const ::File& _internal_fileinfo() const;
  ::File* _internal_mutable_fileinfo();
  public:
  void unsafe_arena_set_allocated_fileinfo(
      ::File* fileinfo);
  ::File* unsafe_arena_release_fileinfo();

  // uint64 CurrentProgress = 1;
  void clear_currentprogress();
  uint64_t currentprogress() const;
  void set_currentprogress(uint64_t value);
  private:
  uint64_t _internal_currentprogress() const;
  void _internal_set_currentprogress(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:FileTransferProgress)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::File* fileinfo_;
    uint64_t currentprogress_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fTransfer_2eproto;
};
// -------------------------------------------------------------------

class FileTransferRequestInit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:FileTransferRequestInit) */ {
 public:
  inline FileTransferRequestInit() : FileTransferRequestInit(nullptr) {}
  ~FileTransferRequestInit() override;
  explicit PROTOBUF_CONSTEXPR FileTransferRequestInit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileTransferRequestInit(const FileTransferRequestInit& from);
  FileTransferRequestInit(FileTransferRequestInit&& from) noexcept
    : FileTransferRequestInit() {
    *this = ::std::move(from);
  }

  inline FileTransferRequestInit& operator=(const FileTransferRequestInit& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileTransferRequestInit& operator=(FileTransferRequestInit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileTransferRequestInit& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileTransferRequestInit* internal_default_instance() {
    return reinterpret_cast<const FileTransferRequestInit*>(
               &_FileTransferRequestInit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(FileTransferRequestInit& a, FileTransferRequestInit& b) {
    a.Swap(&b);
  }
  inline void Swap(FileTransferRequestInit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileTransferRequestInit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FileTransferRequestInit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FileTransferRequestInit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FileTransferRequestInit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FileTransferRequestInit& from) {
    FileTransferRequestInit::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileTransferRequestInit* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "FileTransferRequestInit";
  }
  protected:
  explicit FileTransferRequestInit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSrcFileFieldNumber = 1,
    kDstPathFieldNumber = 3,
    kSrcUserFieldNumber = 2,
    kDstUserFieldNumber = 4,
  };
  // string SrcFile = 1;
  void clear_srcfile();
  const std::string& srcfile() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_srcfile(ArgT0&& arg0, ArgT... args);
  std::string* mutable_srcfile();
  PROTOBUF_NODISCARD std::string* release_srcfile();
  void set_allocated_srcfile(std::string* srcfile);
  private:
  const std::string& _internal_srcfile() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_srcfile(const std::string& value);
  std::string* _internal_mutable_srcfile();
  public:

  // string DstPath = 3;
  void clear_dstpath();
  const std::string& dstpath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dstpath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dstpath();
  PROTOBUF_NODISCARD std::string* release_dstpath();
  void set_allocated_dstpath(std::string* dstpath);
  private:
  const std::string& _internal_dstpath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dstpath(const std::string& value);
  std::string* _internal_mutable_dstpath();
  public:

  // .UserInfo SrcUser = 2;
  bool has_srcuser() const;
  private:
  bool _internal_has_srcuser() const;
  public:
  void clear_srcuser();
  const ::UserInfo& srcuser() const;
  PROTOBUF_NODISCARD ::UserInfo* release_srcuser();
  ::UserInfo* mutable_srcuser();
  void set_allocated_srcuser(::UserInfo* srcuser);
  private:
  const ::UserInfo& _internal_srcuser() const;
  ::UserInfo* _internal_mutable_srcuser();
  public:
  void unsafe_arena_set_allocated_srcuser(
      ::UserInfo* srcuser);
  ::UserInfo* unsafe_arena_release_srcuser();

  // .UserInfo DstUser = 4;
  bool has_dstuser() const;
  private:
  bool _internal_has_dstuser() const;
  public:
  void clear_dstuser();
  const ::UserInfo& dstuser() const;
  PROTOBUF_NODISCARD ::UserInfo* release_dstuser();
  ::UserInfo* mutable_dstuser();
  void set_allocated_dstuser(::UserInfo* dstuser);
  private:
  const ::UserInfo& _internal_dstuser() const;
  ::UserInfo* _internal_mutable_dstuser();
  public:
  void unsafe_arena_set_allocated_dstuser(
      ::UserInfo* dstuser);
  ::UserInfo* unsafe_arena_release_dstuser();

  // @@protoc_insertion_point(class_scope:FileTransferRequestInit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr srcfile_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dstpath_;
    ::UserInfo* srcuser_;
    ::UserInfo* dstuser_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fTransfer_2eproto;
};
// -------------------------------------------------------------------

class FileTransferError final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:FileTransferError) */ {
 public:
  inline FileTransferError() : FileTransferError(nullptr) {}
  ~FileTransferError() override;
  explicit PROTOBUF_CONSTEXPR FileTransferError(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileTransferError(const FileTransferError& from);
  FileTransferError(FileTransferError&& from) noexcept
    : FileTransferError() {
    *this = ::std::move(from);
  }

  inline FileTransferError& operator=(const FileTransferError& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileTransferError& operator=(FileTransferError&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileTransferError& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileTransferError* internal_default_instance() {
    return reinterpret_cast<const FileTransferError*>(
               &_FileTransferError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(FileTransferError& a, FileTransferError& b) {
    a.Swap(&b);
  }
  inline void Swap(FileTransferError* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileTransferError* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FileTransferError* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FileTransferError>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FileTransferError& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FileTransferError& from) {
    FileTransferError::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileTransferError* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "FileTransferError";
  }
  protected:
  explicit FileTransferError(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReasonFieldNumber = 1,
  };
  // .TransferError reason = 1;
  void clear_reason();
  ::TransferError reason() const;
  void set_reason(::TransferError value);
  private:
  ::TransferError _internal_reason() const;
  void _internal_set_reason(::TransferError value);
  public:

  // @@protoc_insertion_point(class_scope:FileTransferError)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int reason_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fTransfer_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// FileTransferRequest

// string SrcFile = 1;
inline void FileTransferRequest::clear_srcfile() {
  _impl_.srcfile_.ClearToEmpty();
}
inline const std::string& FileTransferRequest::srcfile() const {
  // @@protoc_insertion_point(field_get:FileTransferRequest.SrcFile)
  return _internal_srcfile();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileTransferRequest::set_srcfile(ArgT0&& arg0, ArgT... args) {
 
 _impl_.srcfile_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:FileTransferRequest.SrcFile)
}
inline std::string* FileTransferRequest::mutable_srcfile() {
  std::string* _s = _internal_mutable_srcfile();
  // @@protoc_insertion_point(field_mutable:FileTransferRequest.SrcFile)
  return _s;
}
inline const std::string& FileTransferRequest::_internal_srcfile() const {
  return _impl_.srcfile_.Get();
}
inline void FileTransferRequest::_internal_set_srcfile(const std::string& value) {
  
  _impl_.srcfile_.Set(value, GetArenaForAllocation());
}
inline std::string* FileTransferRequest::_internal_mutable_srcfile() {
  
  return _impl_.srcfile_.Mutable(GetArenaForAllocation());
}
inline std::string* FileTransferRequest::release_srcfile() {
  // @@protoc_insertion_point(field_release:FileTransferRequest.SrcFile)
  return _impl_.srcfile_.Release();
}
inline void FileTransferRequest::set_allocated_srcfile(std::string* srcfile) {
  if (srcfile != nullptr) {
    
  } else {
    
  }
  _impl_.srcfile_.SetAllocated(srcfile, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.srcfile_.IsDefault()) {
    _impl_.srcfile_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:FileTransferRequest.SrcFile)
}

// -------------------------------------------------------------------

// FileRecieveRequest

// string DstPath = 1;
inline void FileRecieveRequest::clear_dstpath() {
  _impl_.dstpath_.ClearToEmpty();
}
inline const std::string& FileRecieveRequest::dstpath() const {
  // @@protoc_insertion_point(field_get:FileRecieveRequest.DstPath)
  return _internal_dstpath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileRecieveRequest::set_dstpath(ArgT0&& arg0, ArgT... args) {
 
 _impl_.dstpath_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:FileRecieveRequest.DstPath)
}
inline std::string* FileRecieveRequest::mutable_dstpath() {
  std::string* _s = _internal_mutable_dstpath();
  // @@protoc_insertion_point(field_mutable:FileRecieveRequest.DstPath)
  return _s;
}
inline const std::string& FileRecieveRequest::_internal_dstpath() const {
  return _impl_.dstpath_.Get();
}
inline void FileRecieveRequest::_internal_set_dstpath(const std::string& value) {
  
  _impl_.dstpath_.Set(value, GetArenaForAllocation());
}
inline std::string* FileRecieveRequest::_internal_mutable_dstpath() {
  
  return _impl_.dstpath_.Mutable(GetArenaForAllocation());
}
inline std::string* FileRecieveRequest::release_dstpath() {
  // @@protoc_insertion_point(field_release:FileRecieveRequest.DstPath)
  return _impl_.dstpath_.Release();
}
inline void FileRecieveRequest::set_allocated_dstpath(std::string* dstpath) {
  if (dstpath != nullptr) {
    
  } else {
    
  }
  _impl_.dstpath_.SetAllocated(dstpath, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dstpath_.IsDefault()) {
    _impl_.dstpath_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:FileRecieveRequest.DstPath)
}

// .File fileInfo = 2;
inline bool FileRecieveRequest::_internal_has_fileinfo() const {
  return this != internal_default_instance() && _impl_.fileinfo_ != nullptr;
}
inline bool FileRecieveRequest::has_fileinfo() const {
  return _internal_has_fileinfo();
}
inline const ::File& FileRecieveRequest::_internal_fileinfo() const {
  const ::File* p = _impl_.fileinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::File&>(
      ::_File_default_instance_);
}
inline const ::File& FileRecieveRequest::fileinfo() const {
  // @@protoc_insertion_point(field_get:FileRecieveRequest.fileInfo)
  return _internal_fileinfo();
}
inline void FileRecieveRequest::unsafe_arena_set_allocated_fileinfo(
    ::File* fileinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fileinfo_);
  }
  _impl_.fileinfo_ = fileinfo;
  if (fileinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:FileRecieveRequest.fileInfo)
}
inline ::File* FileRecieveRequest::release_fileinfo() {
  
  ::File* temp = _impl_.fileinfo_;
  _impl_.fileinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::File* FileRecieveRequest::unsafe_arena_release_fileinfo() {
  // @@protoc_insertion_point(field_release:FileRecieveRequest.fileInfo)
  
  ::File* temp = _impl_.fileinfo_;
  _impl_.fileinfo_ = nullptr;
  return temp;
}
inline ::File* FileRecieveRequest::_internal_mutable_fileinfo() {
  
  if (_impl_.fileinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::File>(GetArenaForAllocation());
    _impl_.fileinfo_ = p;
  }
  return _impl_.fileinfo_;
}
inline ::File* FileRecieveRequest::mutable_fileinfo() {
  ::File* _msg = _internal_mutable_fileinfo();
  // @@protoc_insertion_point(field_mutable:FileRecieveRequest.fileInfo)
  return _msg;
}
inline void FileRecieveRequest::set_allocated_fileinfo(::File* fileinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fileinfo_);
  }
  if (fileinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fileinfo));
    if (message_arena != submessage_arena) {
      fileinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fileinfo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.fileinfo_ = fileinfo;
  // @@protoc_insertion_point(field_set_allocated:FileRecieveRequest.fileInfo)
}

// -------------------------------------------------------------------

// FileTransferPart

// bytes Part = 1;
inline void FileTransferPart::clear_part() {
  _impl_.part_.ClearToEmpty();
}
inline const std::string& FileTransferPart::part() const {
  // @@protoc_insertion_point(field_get:FileTransferPart.Part)
  return _internal_part();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileTransferPart::set_part(ArgT0&& arg0, ArgT... args) {
 
 _impl_.part_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:FileTransferPart.Part)
}
inline std::string* FileTransferPart::mutable_part() {
  std::string* _s = _internal_mutable_part();
  // @@protoc_insertion_point(field_mutable:FileTransferPart.Part)
  return _s;
}
inline const std::string& FileTransferPart::_internal_part() const {
  return _impl_.part_.Get();
}
inline void FileTransferPart::_internal_set_part(const std::string& value) {
  
  _impl_.part_.Set(value, GetArenaForAllocation());
}
inline std::string* FileTransferPart::_internal_mutable_part() {
  
  return _impl_.part_.Mutable(GetArenaForAllocation());
}
inline std::string* FileTransferPart::release_part() {
  // @@protoc_insertion_point(field_release:FileTransferPart.Part)
  return _impl_.part_.Release();
}
inline void FileTransferPart::set_allocated_part(std::string* part) {
  if (part != nullptr) {
    
  } else {
    
  }
  _impl_.part_.SetAllocated(part, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.part_.IsDefault()) {
    _impl_.part_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:FileTransferPart.Part)
}

// -------------------------------------------------------------------

// FileTransferProgress

// uint64 CurrentProgress = 1;
inline void FileTransferProgress::clear_currentprogress() {
  _impl_.currentprogress_ = uint64_t{0u};
}
inline uint64_t FileTransferProgress::_internal_currentprogress() const {
  return _impl_.currentprogress_;
}
inline uint64_t FileTransferProgress::currentprogress() const {
  // @@protoc_insertion_point(field_get:FileTransferProgress.CurrentProgress)
  return _internal_currentprogress();
}
inline void FileTransferProgress::_internal_set_currentprogress(uint64_t value) {
  
  _impl_.currentprogress_ = value;
}
inline void FileTransferProgress::set_currentprogress(uint64_t value) {
  _internal_set_currentprogress(value);
  // @@protoc_insertion_point(field_set:FileTransferProgress.CurrentProgress)
}

// .File fileInfo = 2;
inline bool FileTransferProgress::_internal_has_fileinfo() const {
  return this != internal_default_instance() && _impl_.fileinfo_ != nullptr;
}
inline bool FileTransferProgress::has_fileinfo() const {
  return _internal_has_fileinfo();
}
inline const ::File& FileTransferProgress::_internal_fileinfo() const {
  const ::File* p = _impl_.fileinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::File&>(
      ::_File_default_instance_);
}
inline const ::File& FileTransferProgress::fileinfo() const {
  // @@protoc_insertion_point(field_get:FileTransferProgress.fileInfo)
  return _internal_fileinfo();
}
inline void FileTransferProgress::unsafe_arena_set_allocated_fileinfo(
    ::File* fileinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fileinfo_);
  }
  _impl_.fileinfo_ = fileinfo;
  if (fileinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:FileTransferProgress.fileInfo)
}
inline ::File* FileTransferProgress::release_fileinfo() {
  
  ::File* temp = _impl_.fileinfo_;
  _impl_.fileinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::File* FileTransferProgress::unsafe_arena_release_fileinfo() {
  // @@protoc_insertion_point(field_release:FileTransferProgress.fileInfo)
  
  ::File* temp = _impl_.fileinfo_;
  _impl_.fileinfo_ = nullptr;
  return temp;
}
inline ::File* FileTransferProgress::_internal_mutable_fileinfo() {
  
  if (_impl_.fileinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::File>(GetArenaForAllocation());
    _impl_.fileinfo_ = p;
  }
  return _impl_.fileinfo_;
}
inline ::File* FileTransferProgress::mutable_fileinfo() {
  ::File* _msg = _internal_mutable_fileinfo();
  // @@protoc_insertion_point(field_mutable:FileTransferProgress.fileInfo)
  return _msg;
}
inline void FileTransferProgress::set_allocated_fileinfo(::File* fileinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fileinfo_);
  }
  if (fileinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fileinfo));
    if (message_arena != submessage_arena) {
      fileinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fileinfo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.fileinfo_ = fileinfo;
  // @@protoc_insertion_point(field_set_allocated:FileTransferProgress.fileInfo)
}

// -------------------------------------------------------------------

// FileTransferRequestInit

// string SrcFile = 1;
inline void FileTransferRequestInit::clear_srcfile() {
  _impl_.srcfile_.ClearToEmpty();
}
inline const std::string& FileTransferRequestInit::srcfile() const {
  // @@protoc_insertion_point(field_get:FileTransferRequestInit.SrcFile)
  return _internal_srcfile();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileTransferRequestInit::set_srcfile(ArgT0&& arg0, ArgT... args) {
 
 _impl_.srcfile_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:FileTransferRequestInit.SrcFile)
}
inline std::string* FileTransferRequestInit::mutable_srcfile() {
  std::string* _s = _internal_mutable_srcfile();
  // @@protoc_insertion_point(field_mutable:FileTransferRequestInit.SrcFile)
  return _s;
}
inline const std::string& FileTransferRequestInit::_internal_srcfile() const {
  return _impl_.srcfile_.Get();
}
inline void FileTransferRequestInit::_internal_set_srcfile(const std::string& value) {
  
  _impl_.srcfile_.Set(value, GetArenaForAllocation());
}
inline std::string* FileTransferRequestInit::_internal_mutable_srcfile() {
  
  return _impl_.srcfile_.Mutable(GetArenaForAllocation());
}
inline std::string* FileTransferRequestInit::release_srcfile() {
  // @@protoc_insertion_point(field_release:FileTransferRequestInit.SrcFile)
  return _impl_.srcfile_.Release();
}
inline void FileTransferRequestInit::set_allocated_srcfile(std::string* srcfile) {
  if (srcfile != nullptr) {
    
  } else {
    
  }
  _impl_.srcfile_.SetAllocated(srcfile, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.srcfile_.IsDefault()) {
    _impl_.srcfile_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:FileTransferRequestInit.SrcFile)
}

// .UserInfo SrcUser = 2;
inline bool FileTransferRequestInit::_internal_has_srcuser() const {
  return this != internal_default_instance() && _impl_.srcuser_ != nullptr;
}
inline bool FileTransferRequestInit::has_srcuser() const {
  return _internal_has_srcuser();
}
inline const ::UserInfo& FileTransferRequestInit::_internal_srcuser() const {
  const ::UserInfo* p = _impl_.srcuser_;
  return p != nullptr ? *p : reinterpret_cast<const ::UserInfo&>(
      ::_UserInfo_default_instance_);
}
inline const ::UserInfo& FileTransferRequestInit::srcuser() const {
  // @@protoc_insertion_point(field_get:FileTransferRequestInit.SrcUser)
  return _internal_srcuser();
}
inline void FileTransferRequestInit::unsafe_arena_set_allocated_srcuser(
    ::UserInfo* srcuser) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.srcuser_);
  }
  _impl_.srcuser_ = srcuser;
  if (srcuser) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:FileTransferRequestInit.SrcUser)
}
inline ::UserInfo* FileTransferRequestInit::release_srcuser() {
  
  ::UserInfo* temp = _impl_.srcuser_;
  _impl_.srcuser_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::UserInfo* FileTransferRequestInit::unsafe_arena_release_srcuser() {
  // @@protoc_insertion_point(field_release:FileTransferRequestInit.SrcUser)
  
  ::UserInfo* temp = _impl_.srcuser_;
  _impl_.srcuser_ = nullptr;
  return temp;
}
inline ::UserInfo* FileTransferRequestInit::_internal_mutable_srcuser() {
  
  if (_impl_.srcuser_ == nullptr) {
    auto* p = CreateMaybeMessage<::UserInfo>(GetArenaForAllocation());
    _impl_.srcuser_ = p;
  }
  return _impl_.srcuser_;
}
inline ::UserInfo* FileTransferRequestInit::mutable_srcuser() {
  ::UserInfo* _msg = _internal_mutable_srcuser();
  // @@protoc_insertion_point(field_mutable:FileTransferRequestInit.SrcUser)
  return _msg;
}
inline void FileTransferRequestInit::set_allocated_srcuser(::UserInfo* srcuser) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.srcuser_);
  }
  if (srcuser) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(srcuser));
    if (message_arena != submessage_arena) {
      srcuser = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, srcuser, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.srcuser_ = srcuser;
  // @@protoc_insertion_point(field_set_allocated:FileTransferRequestInit.SrcUser)
}

// string DstPath = 3;
inline void FileTransferRequestInit::clear_dstpath() {
  _impl_.dstpath_.ClearToEmpty();
}
inline const std::string& FileTransferRequestInit::dstpath() const {
  // @@protoc_insertion_point(field_get:FileTransferRequestInit.DstPath)
  return _internal_dstpath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileTransferRequestInit::set_dstpath(ArgT0&& arg0, ArgT... args) {
 
 _impl_.dstpath_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:FileTransferRequestInit.DstPath)
}
inline std::string* FileTransferRequestInit::mutable_dstpath() {
  std::string* _s = _internal_mutable_dstpath();
  // @@protoc_insertion_point(field_mutable:FileTransferRequestInit.DstPath)
  return _s;
}
inline const std::string& FileTransferRequestInit::_internal_dstpath() const {
  return _impl_.dstpath_.Get();
}
inline void FileTransferRequestInit::_internal_set_dstpath(const std::string& value) {
  
  _impl_.dstpath_.Set(value, GetArenaForAllocation());
}
inline std::string* FileTransferRequestInit::_internal_mutable_dstpath() {
  
  return _impl_.dstpath_.Mutable(GetArenaForAllocation());
}
inline std::string* FileTransferRequestInit::release_dstpath() {
  // @@protoc_insertion_point(field_release:FileTransferRequestInit.DstPath)
  return _impl_.dstpath_.Release();
}
inline void FileTransferRequestInit::set_allocated_dstpath(std::string* dstpath) {
  if (dstpath != nullptr) {
    
  } else {
    
  }
  _impl_.dstpath_.SetAllocated(dstpath, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dstpath_.IsDefault()) {
    _impl_.dstpath_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:FileTransferRequestInit.DstPath)
}

// .UserInfo DstUser = 4;
inline bool FileTransferRequestInit::_internal_has_dstuser() const {
  return this != internal_default_instance() && _impl_.dstuser_ != nullptr;
}
inline bool FileTransferRequestInit::has_dstuser() const {
  return _internal_has_dstuser();
}
inline const ::UserInfo& FileTransferRequestInit::_internal_dstuser() const {
  const ::UserInfo* p = _impl_.dstuser_;
  return p != nullptr ? *p : reinterpret_cast<const ::UserInfo&>(
      ::_UserInfo_default_instance_);
}
inline const ::UserInfo& FileTransferRequestInit::dstuser() const {
  // @@protoc_insertion_point(field_get:FileTransferRequestInit.DstUser)
  return _internal_dstuser();
}
inline void FileTransferRequestInit::unsafe_arena_set_allocated_dstuser(
    ::UserInfo* dstuser) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dstuser_);
  }
  _impl_.dstuser_ = dstuser;
  if (dstuser) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:FileTransferRequestInit.DstUser)
}
inline ::UserInfo* FileTransferRequestInit::release_dstuser() {
  
  ::UserInfo* temp = _impl_.dstuser_;
  _impl_.dstuser_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::UserInfo* FileTransferRequestInit::unsafe_arena_release_dstuser() {
  // @@protoc_insertion_point(field_release:FileTransferRequestInit.DstUser)
  
  ::UserInfo* temp = _impl_.dstuser_;
  _impl_.dstuser_ = nullptr;
  return temp;
}
inline ::UserInfo* FileTransferRequestInit::_internal_mutable_dstuser() {
  
  if (_impl_.dstuser_ == nullptr) {
    auto* p = CreateMaybeMessage<::UserInfo>(GetArenaForAllocation());
    _impl_.dstuser_ = p;
  }
  return _impl_.dstuser_;
}
inline ::UserInfo* FileTransferRequestInit::mutable_dstuser() {
  ::UserInfo* _msg = _internal_mutable_dstuser();
  // @@protoc_insertion_point(field_mutable:FileTransferRequestInit.DstUser)
  return _msg;
}
inline void FileTransferRequestInit::set_allocated_dstuser(::UserInfo* dstuser) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dstuser_);
  }
  if (dstuser) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dstuser));
    if (message_arena != submessage_arena) {
      dstuser = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dstuser, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.dstuser_ = dstuser;
  // @@protoc_insertion_point(field_set_allocated:FileTransferRequestInit.DstUser)
}

// -------------------------------------------------------------------

// FileTransferError

// .TransferError reason = 1;
inline void FileTransferError::clear_reason() {
  _impl_.reason_ = 0;
}
inline ::TransferError FileTransferError::_internal_reason() const {
  return static_cast< ::TransferError >(_impl_.reason_);
}
inline ::TransferError FileTransferError::reason() const {
  // @@protoc_insertion_point(field_get:FileTransferError.reason)
  return _internal_reason();
}
inline void FileTransferError::_internal_set_reason(::TransferError value) {
  
  _impl_.reason_ = value;
}
inline void FileTransferError::set_reason(::TransferError value) {
  _internal_set_reason(value);
  // @@protoc_insertion_point(field_set:FileTransferError.reason)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::TransferError> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TransferError>() {
  return ::TransferError_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_protos_2fTransfer_2eproto
